	
Label Root
{
	Son: SECTOR
	Label SECTOR
	{
		Son: FIRM
		Label FIRM
		{
			Var: X
			Param: c
			Var: Share_X

		}

		Var: Ave_X
		Var: Max_X
		Var: Sum_Share_X
		Var: Sum_X
		Var: Leader

	}


}


DATA

Object: Root C	1

Object: SECTOR C	1
Var: Ave_X 0 s + n n
Var: Max_X 0 s + n n
Var: Sum_Share_X 0 s + n n
Var: Sum_X 0 s + n n
Var: Leader 0 s + n p

Object: FIRM C	10
Var: X 1 s + n n	0	0	0	0	0	0	0	0	0	0
Param: c 0 n + n n	1	2	3	4	5	6	7	8	9	10
Var: Share_X 0 s + n n

SIM_NUM 1
SEED 1
MAX_STEP 100
EQUATION fun_exercicio.cpp
MODELREPORT report_Sim1.html

DESCRIPTION

Object_Root
(no description available)
END_DESCRIPTION

Object_SECTOR
(no description available)
_INIT_

END_DESCRIPTION

Variable_Ave_X
(no description available)
_INIT_

END_DESCRIPTION

Variable_Max_X
(no description available)
_INIT_

END_DESCRIPTION

Variable_Sum_Share_X
(no description available)
_INIT_

END_DESCRIPTION

Variable_Sum_X
(no description available)
_INIT_

END_DESCRIPTION

Variable_Leader
(no description available)
_INIT_

END_DESCRIPTION

Object_FIRM
(no description available)
_INIT_

END_DESCRIPTION

Variable_X
(no description available)
_INIT_
All 10 instances equal to 0.
END_DESCRIPTION

Parameter_c
(no description available)
_INIT_
All 10 instances ranging from 1 to 10 (increments of 1).
END_DESCRIPTION

Variable_Share_X
(no description available)
_INIT_

END_DESCRIPTION


DOCUOBSERVE

END_DOCUOBSERVE


DOCUINITIAL

END_DOCUINITIAL


EQ_FILE
//#define EIGENLIB			// uncomment to use Eigen linear algebra library
//#define NO_POINTER_INIT	// uncomment to disable pointer checking

#include "fun_head_fast.h"

// do not add Equations in this area

MODELBEGIN


/*
Variável "X" defasada um periodo a partir de um valor aleatório "RND" entre 0 e 1 multiplicado por uma constante "c". - Nivel do Objeto: FIRM
*/
EQUATION("X") 
RESULT(VL("X",1) + (RND * V("c")))


// Variável que Retorna a Soma de todos os X [O mesmo que utilizar a Macro (SUM("X")] - Nivel do Objeto: SECTOR
EQUATION("Sum_X") 
v[0]=0;
CYCLE(cur, "FIRM")
{
	v[1]=VS(cur,"X");
	v[0]=v[0]+v[1];
}
RESULT(v[0])

/* Para conferir o resultado
EQUATION("X_Sum")
RESULT(SUM("X"))
*/

// Variável que Retorna a Média de todos os X [O mesmo que utilizar a Macro (AVE("X")] - Nivel do Objeto: SECTOR
EQUATION("Ave_X") 
v[0]=0;
v[2]=0;
CYCLE(cur, "FIRM")
{
	v[3]=VS(cur,"X");
	v[0]=v[0]+v[3];
	v[1]= COUNT_ALLS(cur,"FIRM");
}
if(v[1]!=0) v[2]=v[0]/v[1];	
else v[2]=0;
RESULT(v[2])

/*Para conferir o resultado
EQUATION("X_Ave")
RESULT(AVE("X"))
*/

// Retorna o valor Máximo de todos os X [O mesmo que utilizar a Macro (MAX("X")] - Nivel do Objeto: SECTOR
EQUATION("Max_X") 
v[0]=0;
CYCLE(cur, "FIRM")
{
	v[1]=VS(cur,"X");
	if(v[1]>v[0])	v[0]=v[1]; 
	else v[0]=v[0];
}
RESULT(v[0])

/*
Participação de cada X em Relação ao valor total de todos os X [Seria igual a "Participação no Mercado de cada Firma"] - Nivel do Objeto: FIRM
*/
EQUATION("Share_X") 
RESULT((V("X")/V("X_Sum")))


// Somatório das Participações de cada Firma [Deve somar 1] - Nivel do Objeto: FIRM
EQUATION("Sum_Share_X") 
v[0]=0;
CYCLE(cur, "FIRM")
{
	v[1]=VS(cur,"X_Share");
	v[0]=v[0]+v[1];
}
RESULT(v[0])


/*
EQUATION("Leader") //Who is the boss?
v[0]=0; //Share do campeão
v[1]=0; //Token de posição
v[2]=1; //Token de campeão
CYCLE(cur, "FIRM")
{
	v[3]=VS(cur,"X_Share");
	if(v[3]<v[0]) 
	{v[2]=v[2]+1;} //Challenger perde e aumenta token do campeão
	else
	{v[0]=v[3] ; v[1]=v[1]+v[2] ; v[2]=1;} //Challenger ganha, vira novo campeão, transfere tokens do campeão para posição e reinicia o streak de vitórias
}
RESULT(v[1])
*/

MODELEND

// do not add Equations in this area

void close_sim( void )
{
	// close simulation special commands go here
}

END_EQ_FILE
